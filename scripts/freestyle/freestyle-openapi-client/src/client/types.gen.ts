// This file is auto-generated by @hey-api/openapi-ts

export type AccessLevel = 'read' | 'write';

export type AccessTokenInfo = {
    id: string;
};

/**
 * Identical to [`RepositoryInfo`], but with the permissions field added.
 */
export type AccessibleRepository = {
    id: string;
    name?: string | null;
    accountId: string;
    permissions: AccessLevel;
    visibility: Visibility;
};

export type Behavior = 'regex' | 'exact';

/**
 * The encoding of a blob from the API. Always `base64`.
 */
export type BlobEncoding = 'base64';

/**
 * Blob object
 */
export type BlobObject = {
    /**
     * The content of the blob, base64 encoded.
     */
    content: string;
    /**
     * The encoding of the blob. Always `base64`.
     */
    encoding: BlobEncoding;
    /**
     * The object's hash.
     */
    sha: string;
};

export type BranchDetails = {
    default: boolean;
    name: string;
    target?: string | null;
};

export type CommitList = {
    /**
     * List of commits
     */
    commits: Array<CommitObject>;
    /**
     * Number of commits returned in this page
     */
    count: number;
    /**
     * Number of commits skipped (offset)
     */
    offset: number;
    /**
     * Maximum number of commits requested (limit)
     */
    limit: number;
    /**
     * Total number of commits available in the branch
     */
    total: number;
};

/**
 * Commit object
 */
export type CommitObject = {
    /**
     * The author of the commit
     */
    author: Signature;
    /**
     * The committer
     */
    committer: Signature;
    /**
     * The commit message
     */
    message: string;
    /**
     * The ID of the tree pointed to by this commit
     */
    tree: CommitTree;
    /**
     * Parent commit(s) of this commit
     */
    parents: Array<CommitParent>;
    /**
     * The commit's hash ID
     */
    sha: string;
};

export type CommitParent = {
    /**
     * The commit's hash ID
     */
    sha: string;
};

export type CommitTree = {
    /**
     * The tree's hash ID
     */
    sha: string;
};

export type ConfigureGithubSyncRequest = {
    /**
     * The GitHub repository name in "owner/repo" format
     */
    githubRepoName: string;
};

export type CreateDomainMappingRequest = {
    deploymentId: string;
};

export type CreateRecordParams = {
    domain: string;
    record: DnsRecordData;
};

export type CreateRecordResponse = {
    record: DnsRecord;
};

export type CreateRepoImport = {
    /**
     * Files
     * A map of file names to their contents.
     */
    files: {
        [key: string]: string;
    };
    commitMessage: string;
    authorName?: string | null;
    authorEmail?: string | null;
    type: 'files';
} | {
    url: string;
    dir?: string | null;
    commitMessage: string;
    authorName?: string | null;
    authorEmail?: string | null;
    type: 'tar';
} | {
    url: string;
    dir?: string | null;
    commitMessage: string;
    authorName?: string | null;
    authorEmail?: string | null;
    type: 'zip';
} | {
    url: string;
    branch?: string | null;
    dir?: string | null;
    commitMessage: string;
    authorName?: string | null;
    authorEmail?: string | null;
    type: 'git';
};

export type CreateRepoRequest = {
    source?: null | CreateRepoSource;
    import?: null | CreateRepoImport;
    defaultBranch?: string | null;
};

export type CreateRepoSource = {
    url: string;
    branch?: string | null;
    depth?: number | null;
};

export type CreateRepositoryRequest = {
    /**
     * This name is not visible to users, and is only accessible to you via API and in the
     * dashboard. Mostly useful for observability.
     */
    name?: string | null;
    public?: boolean;
    /**
     * The default branch name for the repository. Defaults to "main" if not specified.
     */
    defaultBranch?: string | null;
    /**
     * Fork from another Git repository. Cannot be used with `import`.
     */
    source?: CreateRepoSource;
    /**
     * Import static content with an initial commit. Cannot be used with `source`.
     */
    import?: CreateRepoImport;
};

export type CreateRepositoryResponseSuccess = {
    repoId: string;
};

export type CreateVmRequest = {
    idleTimeoutSeconds?: number | null;
    /**
     * Optional list of ports to expose externally. If not provided, port 3000
     * will be exposed on port 443 by default. Pass an empty array to disable
     * external ports. Only ports 8081 and 443 can be configured externally for
     * now. Any target port is allowed.
     */
    ports?: Array<PortMapping> | null;
    /**
     * Whether the api request should wait for the VM to be ready before
     * returning. By default, the VM is considered ready when the serial
     * console is ready for login.
     */
    waitForReadySignal?: boolean | null;
    /**
     * How long to wait for the ready signal before timing out. Defaults to 120
     * seconds if not provided.
     */
    readySignalTimeoutSeconds?: number | null;
    /**
     * Optional working directory for the VM. File system and shell commands
     * will be executed in this directory.
     */
    workdir?: string | null;
    persistence?: null | VmPersistence;
};

export type CreatedToken = {
    id: string;
    token: string;
};

export type CustomBuildOptions = {
    command?: string | null;
    envVars?: {
        [key: string]: string;
    } | null;
    outDir?: string | null;
};

export type DeleteRecordResponse = {
    message: string;
};

export type DeploymentBuildOptions = CustomBuildOptions | boolean;

export type DeploymentLogEntry = {
    deploymentId: string;
    accountId: string;
    provisionedAt: string;
    timeout: string;
    state: DeploymentState;
    deployedAt?: string | null;
    domains: Array<string>;
    envVars: {
        [key: string]: string;
    };
};

export type DeploymentSource = {
    files: {
        [key: string]: FreestyleFile;
    };
    kind: 'files';
} | {
    url: string;
    kind: 'tar';
} | {
    url: string;
    branch?: string | null;
    dir?: string | null;
    kind: 'git';
};

export type DeploymentState = 'provisioning' | 'deployed' | 'failed';

export type DescribePermissionResponseSuccess = {
    identity: string;
    repo: string;
    accessLevel?: null | AccessLevel;
};

export type DevServer = {
    repoId: string;
    gitRef?: string | null;
    kind: 'repo';
};

export type DevServerLogsRequest = {
    devServer: DevServer;
    /**
     * Number of log lines to return per page (default 200)
     */
    count?: number | null;
    /**
     * 1-based page index. page=1 returns the most recent lines (default 1)
     */
    page?: number | null;
};

export type DevServerRequest = {
    devCommand?: string | null;
    installCommand?: string | null;
    preDevCommandOnce?: string | null;
    /**
     * @deprecated
     */
    baseId?: string | null;
    envVars?: {
        [key: string]: string;
    } | null;
    repoId?: string | null;
    computeClass?: string | null;
    /**
     * Timeout in seconds
     */
    timeout?: number | null;
    /**
     * @deprecated
     */
    domain?: string | null;
    /**
     * @deprecated
     */
    repo?: string | null;
    gitRef?: string | null;
    /**
     * Optional list of ports to expose externally. If not provided, port 3000 will be exposed on port 443 by default. Pass an empty array to disable external ports.
     * Only ports 8081 and 443 can be configured externally for now. Any target port is allowed.
     */
    ports?: Array<PortConfig> | null;
};

export type DevServerRestartRequest = {
    devServer: DevServer;
};

export type DevServerStatusRequest = {
    devServer: DevServer;
};

export type DevServerWatchFilesRequest = {
    devServer: DevServer;
};

export type DnsRecord = {
    kind: DnsRecordKind;
    name: string;
    value: string;
    ttl: string;
    priority?: number | null;
    managed: boolean;
};

export type DnsRecordData = {
    kind: DnsRecordKind;
    name: string;
    value: string;
    ttl?: string | null;
    priority?: number | null;
};

export type DnsRecordKind = 'A' | 'AAAA' | 'CNAME' | 'TXT' | 'NS';

export type DomainVerificationRequest = {
    id: string;
    domain: string;
    accountId: string;
    verificationCode: string;
    createdAt: string;
};

export type ExecAwaitRequest = {
    command: string;
    terminal?: string | null;
};

export type ExecRequest = {
    devServer: DevServer;
    command: string;
    /**
     * Spawn this command as a background process and return immediately
     */
    background: boolean;
};

export type ExecuteLogEntry = {
    deployment: string;
    accountId: string;
    provisionedAt: string;
    startedAt?: string | null;
    duration?: string | null;
    state: ExecuteRunState;
    envVars: {
        [key: string]: string;
    };
};

export type ExecuteRunInfo = {
    code: string;
    nodeModules: {
        [key: string]: string;
    };
};

export type ExecuteRunState = 'starting' | 'running' | 'complete';

export type FileReadContent = {
    content: string;
    encoding: string;
    kind: 'file';
} | {
    files: Array<string>;
    kind: 'directory';
};

export type ForkVmRequest = {
    idleTimeoutSeconds?: number | null;
    /**
     * Optional list of ports to expose externally. If not provided, port 3000
     * will be exposed on port 443 by default. Pass an empty array to disable
     * external ports. Only ports 8081 and 443 can be configured externally for
     * now. Any target port is allowed.
     */
    ports?: Array<PortMapping> | null;
    /**
     * Whether the api request should wait for the VM to be ready before
     * returning. By default, the VM is considered ready when the serial
     * console is ready for login.
     */
    readySignalTimeoutSeconds?: number | null;
    /**
     * How long to wait for the ready signal before timing out. Defaults to 120
     * seconds if not provided.
     */
    waitForReadySignal?: boolean | null;
    /**
     * Optional working directory for the VM. File system and shell commands
     * will be executed in this directory.
     */
    workdir?: string | null;
    persistence?: null | VmPersistence;
};

export type FreestyleCloudstateDeployConfiguration = {
    /**
     * ID of the project to deploy, if not provided will create a new project
     */
    domains?: Array<string> | null;
    /**
     * The environment variables that the cloudstate deploy can access
     */
    envVars?: {
        [key: string]: string;
    };
    cloudstateDatabaseId?: string | null;
};

export type FreestyleCloudstateDeployErrorResponse = {
    message: string;
};

export type FreestyleCloudstateDeployRequest = {
    classes: string;
    config?: FreestyleCloudstateDeployConfiguration;
};

export type FreestyleCloudstateDeploySuccessResponse = {
    deploymentId: string;
    cloudstateDatabaseId: string;
};

export type FreestyleDeleteDomainVerificationRequest = {
    /**
     * The domain to create a verification code for
     */
    domain: string;
    /**
     * The verification code
     */
    verificationCode: string;
};

export type FreestyleDeployWebConfiguration = {
    /**
     * The entrypoint file for the website, if none is provided, we will try to automatically detect it.
     */
    entrypoint?: string | null;
    /**
     * The custom domains for the website, eg. [\"subdomain.yourwebsite.com\"]. You may include a single *.style.dev domain here.
     */
    domains?: Array<string> | null;
    /**
     * Project ID was our original way of tracking deployments together, it is now deprecated and will be removed in the future. Please use the domains field to specify the domains for your project.
     * @deprecated
     */
    projectId?: string | null;
    /**
     * Node Modules to install for the website, a map of package names to versions, e.g. { \"express\": \"4.17.1\" }. If this and a package-lock.json are provided, the package-lock.json, bun.lockb, pnpm-lock.yaml, or yarn.lock is also provided, the versions here will override the versions in those lock files.
     */
    nodeModules?: {
        [key: string]: string;
    } | null;
    /**
     * The environment variables that the website can access
     * e.g. { \"RESEND_API_KEY\": \"re_123456789\" }
     */
    envVars?: {
        [key: string]: string;
    } | null;
    serverStartCheck?: boolean;
    networkPermissions?: Array<FreestyleNetworkPermission> | null;
    build?: null | DeploymentBuildOptions;
    /**
     * Timeout for the deployment in seconds. If not provided, the default is 10 seconds.
     */
    timeout?: number | null;
};

export type FreestyleDeployWebErrorResponse = {
    message: string;
};

export type FreestyleDeployWebPayload = {
    /**
     * The files to deploy, a map of file paths to file contents, e.g. { \"index.js\": {\"content\": \"your main\", \"encoding\": \"utf-8\"}, \"file2.js\": {\"content\": \"your helper\" } }
     *
     * **Do not include node modules in this bundle, they will not work**. Instead, includes a package-lock.json, bun.lockb, pnpm-lock.yaml, or yarn.lock, the node modules for the project will be installed from that lock file, or use the node_modules field in the configuration to specify the node modules to install.
     */
    files: {
        [key: string]: FreestyleFile;
    };
    config?: FreestyleDeployWebConfiguration;
};

export type FreestyleDeployWebPayloadV2 = {
    /**
     * The files to deploy, a map of file paths to file contents, e.g. { \"index.js\": {\"content\": \"your main\", \"encoding\": \"utf-8\"}, \"file2.js\": {\"content\": \"your helper\" } }
     *
     * **Do not include node modules in this bundle, they will not work**. Instead, includes a package-lock.json, bun.lockb, pnpm-lock.yaml, or yarn.lock, the node modules for the project will be installed from that lock file, or use the node_modules field in the configuration to specify the node modules to install.
     */
    source: DeploymentSource;
    config?: FreestyleDeployWebConfiguration;
};

export type FreestyleDeployWebSuccessResponseV2 = {
    deploymentId: string;
    /**
     * @deprecated
     */
    projectId: string;
    domains?: Array<string> | null;
    /**
     * The entrypoint file for the website. If not specified we try to automatically detect it.
     */
    entrypoint: string;
};

export type FreestyleDomainVerificationRequest = {
    /**
     * The domain to create a verification code for
     */
    domain: string;
};

export type FreestyleExecuteScriptParams = {
    /**
     * The JavaScript or TypeScript script to execute
     */
    script: string;
    config?: FreestyleExecuteScriptParamsConfiguration;
};

export type FreestyleExecuteScriptParamsConfiguration = {
    /**
     * The environment variables to set for the script
     */
    envVars?: {
        [key: string]: string;
    };
    /**
     * The node modules to install for the script
     */
    nodeModules?: {
        [key: string]: string;
    };
    /**
     * Tags for you to organize your scripts, useful for tracking what you're running
     */
    tags?: Array<string>;
    /**
     * The script timeout
     */
    timeout?: number | null;
    /**
     * If false, we'll not resolve peer dependencies for the packages given, this can speed up execute performance, but will break packages with peers unless the peers are manually specified.
     */
    peerDependencyResolution?: boolean;
    networkPermissions?: Array<FreestyleNetworkPermission> | null;
    /**
     * These headers will be added to every fetch request made through the script
     */
    customHeaders?: {
        [key: string]: string;
    };
    /**
     * Proxy all outgoing requests through this URL
     */
    proxy?: string | null;
};

export type FreestyleExecuteScriptResultSuccess = {
    /**
     * The return value of the default export of the script
     */
    result: unknown;
    logs: Array<FreestyleJavaScriptLog>;
};

export type FreestyleFile = {
    /**
     * The content of the file
     */
    content: string;
    /**
     * The encoding of the file. Either **utf-8** or **base64**
     */
    encoding?: string;
};

export type FreestyleGetLogsResponse = {
    logs: Array<FreestyleLogResponseObject>;
};

export type FreestyleJavaScriptLog = {
    /**
     * The log message
     */
    message: string;
    /**
     * The log level
     */
    type: string;
};

export type FreestyleLogResponseObject = {
    message: string;
    timestamp: string;
};

export type FreestyleNetworkPermission = (NetworkPermissionData & {
    action: 'allow';
}) | (NetworkPermissionData & {
    action: 'deny';
});

export type FreestyleSandboxDomainMapping = {
    id: string;
    domain: string;
    deploymentId: string;
    ownershipId: string;
    createdAt: string;
};

/**
 * Verify a domain verification request, can either be done for a domain, or for a specific request
 */
export type FreestyleVerifyDomainRequest = {
    domain: string;
} | {
    id: string;
};

export type GetDefaultBranchResponse = {
    defaultBranch: string;
};

export type GitCommitPushRequest = {
    devServer: DevServer;
    message: string;
};

export type GitContents = {
    name: string;
    path: string;
    /**
     * The hash / object ID of the file.
     */
    sha: string;
    size: number;
    /**
     * Base64-encoded content.
     */
    content: string;
    type: 'file';
} | {
    name: string;
    path: string;
    /**
     * The hash / object ID of the directory.
     */
    sha: string;
    entries: Array<GitContentsDirEntryItem>;
    type: 'dir';
};

export type GitContentsDirEntryItem = {
    name: string;
    path: string;
    /**
     * The hash / object ID of the file.
     */
    sha: string;
    size: number;
    type: 'file';
} | {
    name: string;
    path: string;
    /**
     * The hash / object ID of the directory.
     */
    sha: string;
    entries: Array<{
        [key: string]: unknown;
    } | {
        [key: string]: unknown;
    }>;
    type: 'dir';
};

export type GitIdentity = {
    id: string;
    managed: boolean;
};

/**
 * A reference to a Git object
 */
export type GitReference = {
    /**
     * The name of the ref (e.g., "refs/heads/main" or "refs/tags/v1.0.0")
     */
    name: string;
    /**
     * The SHA-1 hash of the Git object this reference points to
     */
    sha: string;
};

export type GitRepositoryTrigger = {
    repositoryId: string;
    trigger: {
        branches?: Array<string> | null;
        globs?: Array<string> | null;
        event: 'push';
    };
    action: {
        endpoint: string;
        action: 'webhook';
    };
    managed: boolean;
    id: string;
    createdAt: string;
};

export type GitTrigger = {
    branches?: Array<string> | null;
    globs?: Array<string> | null;
    event: 'push';
};

export type GitTriggerAction = {
    endpoint: string;
    action: 'webhook';
};

export type GithubRepoSyncConfig = {
    freestyleRepoId: string;
    accountId: string;
    installationId: number;
    githubRepoId: number;
    githubRepoName: string;
    createdAt: string;
};

export type GithubSyncConfigResponse = {
    githubRepoName: string;
};

export type GrantPermissionRequest = {
    permission: AccessLevel;
};

export type InternalServerError = string;

export type ListGitTokensResponseSuccess = {
    tokens: Array<AccessTokenInfo>;
};

export type ListPermissionResponseSuccess = {
    repositories: Array<AccessibleRepository>;
};

export type ListRecordsResponse = {
    records: Array<DnsRecord>;
};

export type NetworkPermissionData = {
    query: string;
    behavior?: Behavior;
};

export type PortConfig = {
    port: number;
    targetPort: number;
};

export type PortMapping = {
    port: number;
    targetPort: number;
};

export type ReadFileEphemeralDevServerResponses = {
    id: string;
    isNew: boolean;
    content: {
        content: string;
        encoding: string;
        kind: 'file';
    } | {
        files: Array<string>;
        kind: 'directory';
    };
} | {
    id: string;
    isNew: boolean;
} | InternalServerError;

export type RepositoryInfo = {
    id: string;
    name?: string | null;
    accountId: string;
    visibility: Visibility;
    defaultBranch: string;
};

export type RepositoryMetadata = {
    branches: {
        [key: string]: BranchDetails;
    };
    tags: {
        [key: string]: TagDetails;
    };
    defaultBranch: string;
};

export type ResizeVmRequest = {
    sizeMb: number;
};

export type RevokeGitTokenRequest = {
    tokenId: string;
};

export type SetDefaultBranchRequest = {
    defaultBranch: string;
};

export type SetDefaultBranchResponse = {
    [key: string]: unknown;
};

export type ShutdownDevServerRequest = {
    /**
     * The dev server to shutdown
     */
    devServer: DevServer;
};

export type Signature = {
    /**
     * The date marker for this signature
     */
    date: string;
    name: string;
    email: string;
};

export type StartVmRequest = {
    idleTimeoutSeconds?: number | null;
    readySignalTimeoutSeconds?: number | null;
    waitForReadySignal?: boolean | null;
};

export type TagDetails = {
    name: string;
    target: string;
    message?: string | null;
};

/**
 * Tag object
 */
export type TagObject = {
    /**
     * The tag name
     */
    name: string;
    tagger?: null | Signature;
    /**
     * The tag message
     */
    message?: string | null;
    /**
     * The object this tag points to
     */
    target: TagTarget;
    /**
     * The tag's hash ID
     */
    sha: string;
};

export type TagTarget = {
    /**
     * The target object's hash ID
     */
    sha: string;
};

export type TreeEntry = {
    path: string;
    sha: string;
    type: 'blob';
} | {
    path: string;
    sha: string;
    type: 'tree';
};

/**
 * Tree object
 */
export type TreeObject = {
    /**
     * The tree's entries
     */
    tree: Array<TreeEntry>;
    /**
     * The tree's hash ID
     */
    sha: string;
};

export type UpdatePermissionRequest = {
    permission: AccessLevel;
};

export type Visibility = 'public' | 'private';

export type VmPersistence = {
    /**
     * Priority for eviction when storage quota is reached. Higher values
     * mean the VM is less likely to be evicted. Range is 0-10, default is
     * 5.
     */
    priority?: number | null;
    type: 'sticky';
} | {
    type: 'ephemeral';
} | {
    type: 'persistent';
};

export type WriteFileRequest = {
    content: string;
};

export type HandleDeployCloudstateData = {
    body: FreestyleCloudstateDeployRequest;
    path?: never;
    query?: never;
    url: '/cloudstate/v1/deploy';
};

export type HandleDeployCloudstateErrors = {
    /**
     * failed to deploy
     */
    500: FreestyleCloudstateDeployErrorResponse;
};

export type HandleDeployCloudstateError = HandleDeployCloudstateErrors[keyof HandleDeployCloudstateErrors];

export type HandleDeployCloudstateResponses = {
    /**
     * successfully deployed
     */
    200: FreestyleCloudstateDeploySuccessResponse;
};

export type HandleDeployCloudstateResponse = HandleDeployCloudstateResponses[keyof HandleDeployCloudstateResponses];

export type HandleBackupCloudstateData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/cloudstate/v1/projects/{id}/backup';
};

export type HandleBackupCloudstateErrors = {
    /**
     * failed to backup
     */
    500: unknown;
};

export type HandleBackupCloudstateResponses = {
    /**
     * successfully backed up
     */
    200: Array<number>;
};

export type HandleBackupCloudstateResponse = HandleBackupCloudstateResponses[keyof HandleBackupCloudstateResponses];

export type HandleDeleteRecordData = {
    body?: never;
    path?: never;
    query: {
        domain: string;
        record: DnsRecord;
    };
    url: '/dns/v1/records';
};

export type HandleDeleteRecordErrors = {
    /**
     * Account does not own the domain
     */
    403: {
        domain: string;
        account_id: string;
    };
    /**
     * Error deleting DNS record
     */
    500: {
        domain: string;
        name: string;
    };
};

export type HandleDeleteRecordError = HandleDeleteRecordErrors[keyof HandleDeleteRecordErrors];

export type HandleDeleteRecordResponses = {
    200: DeleteRecordResponse;
};

export type HandleDeleteRecordResponse = HandleDeleteRecordResponses[keyof HandleDeleteRecordResponses];

export type HandleListRecordsData = {
    body?: never;
    path?: never;
    query: {
        domain: string;
    };
    url: '/dns/v1/records';
};

export type HandleListRecordsErrors = {
    400: {
        message: string;
    };
};

export type HandleListRecordsError = HandleListRecordsErrors[keyof HandleListRecordsErrors];

export type HandleListRecordsResponses = {
    200: ListRecordsResponse;
};

export type HandleListRecordsResponse = HandleListRecordsResponses[keyof HandleListRecordsResponses];

export type HandleCreateRecordData = {
    body: CreateRecordParams;
    path?: never;
    query?: never;
    url: '/dns/v1/records';
};

export type HandleCreateRecordErrors = {
    /**
     * Account does not own the domain
     */
    403: {
        domain: string;
        account_id: string;
    };
    /**
     * Error creating DNS record
     */
    500: {
        message: string;
    };
};

export type HandleCreateRecordError = HandleCreateRecordErrors[keyof HandleCreateRecordErrors];

export type HandleCreateRecordResponses = {
    200: CreateRecordResponse;
};

export type HandleCreateRecordResponse = HandleCreateRecordResponses[keyof HandleCreateRecordResponses];

export type HandleVerifyWildcardData = {
    body?: never;
    path: {
        domain: string;
    };
    query?: never;
    url: '/domains/v1/certs/{domain}/wildcard';
};

export type HandleVerifyWildcardErrors = {
    /**
     * Failed to preverify domain
     */
    400: {
        message: string;
    };
};

export type HandleVerifyWildcardError = HandleVerifyWildcardErrors[keyof HandleVerifyWildcardErrors];

export type HandleVerifyWildcardResponses = {
    /**
     * Domain verified
     */
    200: {
        domain: string;
    };
};

export type HandleVerifyWildcardResponse = HandleVerifyWildcardResponses[keyof HandleVerifyWildcardResponses];

export type HandleListDomainsData = {
    body?: never;
    path?: never;
    query?: {
        limit?: number | null;
        offset?: number | null;
        implicitlyOwned?: boolean | null;
    };
    url: '/domains/v1/domains';
};

export type HandleListDomainsErrors = {
    /**
     * Failed to get domains
     */
    400: {
        message: string;
    };
};

export type HandleListDomainsError = HandleListDomainsErrors[keyof HandleListDomainsErrors];

export type HandleListDomainsResponses = {
    /**
     * List of domains
     */
    200: Array<{
        domain: string;
        accountId: string;
        createdAt: string;
        id: string;
        verifiedDns: boolean;
        implicitlyOwned: boolean;
        deployToDomain: boolean;
        manageDns: boolean;
        deployToSubdomains: boolean;
    }>;
};

export type HandleListDomainsResponse = HandleListDomainsResponses[keyof HandleListDomainsResponses];

export type HandleListDomainMappingsData = {
    body?: never;
    path?: never;
    query?: {
        offset?: number | null;
        limit?: number | null;
        domainOwnership?: string | null;
        domain?: string | null;
    };
    url: '/domains/v1/mappings';
};

export type HandleListDomainMappingsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type HandleListDomainMappingsResponses = {
    /**
     * List of domain mappings
     */
    200: Array<FreestyleSandboxDomainMapping>;
};

export type HandleListDomainMappingsResponse = HandleListDomainMappingsResponses[keyof HandleListDomainMappingsResponses];

export type HandleDeleteDomainMappingData = {
    body?: never;
    path: {
        domain: string;
    };
    query?: never;
    url: '/domains/v1/mappings/{domain}';
};

export type HandleDeleteDomainMappingErrors = {
    /**
     * You do not have permission to do this
     */
    401: {
        message: string;
    };
    /**
     * Failed to insert ownership
     */
    500: {
        message: string;
    };
    /**
     * Failed to check permissions
     */
    502: {
        message: string;
    };
};

export type HandleDeleteDomainMappingError = HandleDeleteDomainMappingErrors[keyof HandleDeleteDomainMappingErrors];

export type HandleDeleteDomainMappingResponses = {
    /**
     * Successfully removed domain mapping to deployment
     */
    200: unknown;
};

export type HandleInsertDomainMappingData = {
    body: CreateDomainMappingRequest;
    path: {
        domain: string;
    };
    query?: never;
    url: '/domains/v1/mappings/{domain}';
};

export type HandleInsertDomainMappingErrors = {
    /**
     * You do not have permission to do this
     */
    401: {
        message: string;
    };
    /**
     * Failed to provision certificate
     */
    422: {
        message: string;
    };
    /**
     * Failed to insert ownership
     */
    500: {
        message: string;
    };
    /**
     * Failed to check permissions
     */
    502: {
        message: string;
    };
};

export type HandleInsertDomainMappingError = HandleInsertDomainMappingErrors[keyof HandleInsertDomainMappingErrors];

export type HandleInsertDomainMappingResponses = {
    /**
     * Successfully mapped domain to deployment
     */
    200: FreestyleSandboxDomainMapping;
};

export type HandleInsertDomainMappingResponse = HandleInsertDomainMappingResponses[keyof HandleInsertDomainMappingResponses];

export type HandleDeleteDomainVerificationData = {
    body: FreestyleDeleteDomainVerificationRequest;
    path?: never;
    query?: never;
    url: '/domains/v1/verifications';
};

export type HandleDeleteDomainVerificationErrors = {
    /**
     * Failed to create verification code
     */
    400: {
        message: string;
    };
};

export type HandleDeleteDomainVerificationError = HandleDeleteDomainVerificationErrors[keyof HandleDeleteDomainVerificationErrors];

export type HandleDeleteDomainVerificationResponses = {
    /**
     * Verification code created
     */
    200: {
        verificationCode: string;
        domain: string;
    };
};

export type HandleDeleteDomainVerificationResponse = HandleDeleteDomainVerificationResponses[keyof HandleDeleteDomainVerificationResponses];

export type HandleListDomainVerificationRequestsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/domains/v1/verifications';
};

export type HandleListDomainVerificationRequestsErrors = {
    /**
     * Failed to get verification codes
     */
    400: {
        message: string;
    };
};

export type HandleListDomainVerificationRequestsError = HandleListDomainVerificationRequestsErrors[keyof HandleListDomainVerificationRequestsErrors];

export type HandleListDomainVerificationRequestsResponses = {
    /**
     * List of verification codes
     */
    200: Array<{
        verificationCode: string;
        domain: string;
        createdAt: string;
    }>;
};

export type HandleListDomainVerificationRequestsResponse = HandleListDomainVerificationRequestsResponses[keyof HandleListDomainVerificationRequestsResponses];

export type HandleCreateDomainVerificationData = {
    body: FreestyleDomainVerificationRequest;
    path?: never;
    query?: never;
    url: '/domains/v1/verifications';
};

export type HandleCreateDomainVerificationErrors = {
    /**
     * Failed to create verification code
     */
    400: {
        message: string;
    };
};

export type HandleCreateDomainVerificationError = HandleCreateDomainVerificationErrors[keyof HandleCreateDomainVerificationErrors];

export type HandleCreateDomainVerificationResponses = {
    /**
     * Verification code created
     */
    200: DomainVerificationRequest;
};

export type HandleCreateDomainVerificationResponse = HandleCreateDomainVerificationResponses[keyof HandleCreateDomainVerificationResponses];

export type HandleVerifyDomainData = {
    body: FreestyleVerifyDomainRequest;
    path?: never;
    query?: never;
    url: '/domains/v1/verifications';
};

export type HandleVerifyDomainErrors = {
    /**
     * Failed to verify domain
     */
    400: {
        message: string;
    };
    /**
     * Domain verification request not found
     */
    404: {
        message: string;
    };
};

export type HandleVerifyDomainError = HandleVerifyDomainErrors[keyof HandleVerifyDomainErrors];

export type HandleVerifyDomainResponses = {
    /**
     * Domain verified
     */
    200: {
        domain: string;
    };
};

export type HandleVerifyDomainResponse = HandleVerifyDomainResponses[keyof HandleVerifyDomainResponses];

export type HandleEphemeralDevServerData = {
    body: DevServerRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers';
};

export type HandleEphemeralDevServerErrors = {
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HandleEphemeralDevServerError = HandleEphemeralDevServerErrors[keyof HandleEphemeralDevServerErrors];

export type HandleEphemeralDevServerResponses = {
    /**
     * Successful
     */
    200: {
        /**
         * @deprecated
         */
        url: string;
        isNew: boolean;
        devCommandRunning: boolean;
        installCommandRunning: boolean;
        mcpEphemeralUrl?: string | null;
        ephemeralUrl?: string | null;
        vmId?: string | null;
        baseId?: string | null;
    };
};

export type HandleEphemeralDevServerResponse = HandleEphemeralDevServerResponses[keyof HandleEphemeralDevServerResponses];

export type HandleExecOnEphemeralDevServerData = {
    body: ExecRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/exec';
};

export type HandleExecOnEphemeralDevServerErrors = {
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HandleExecOnEphemeralDevServerError = HandleExecOnEphemeralDevServerErrors[keyof HandleExecOnEphemeralDevServerErrors];

export type HandleExecOnEphemeralDevServerResponses = {
    /**
     * Successful
     */
    200: {
        id: string;
        isNew: boolean;
        stdout?: Array<string> | null;
        stderr?: Array<string> | null;
    };
};

export type HandleExecOnEphemeralDevServerResponse = HandleExecOnEphemeralDevServerResponses[keyof HandleExecOnEphemeralDevServerResponses];

export type HandleReadFileFromEphemeralDevServerData = {
    body?: never;
    path: {
        /**
         * The path to the file to read from the dev server
         */
        filepath: string;
    };
    query?: never;
    url: '/ephemeral/v1/dev-servers/files/{filepath}';
};

export type HandleReadFileFromEphemeralDevServerErrors = {
    /**
     * Not found
     */
    404: {
        id: string;
        isNew: boolean;
    };
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HandleReadFileFromEphemeralDevServerError = HandleReadFileFromEphemeralDevServerErrors[keyof HandleReadFileFromEphemeralDevServerErrors];

export type HandleReadFileFromEphemeralDevServerResponses = {
    /**
     * Successful
     */
    200: {
        id: string;
        isNew: boolean;
        content: {
            content: string;
            encoding: string;
            kind: 'file';
        } | {
            files: Array<string>;
            kind: 'directory';
        };
    };
};

export type HandleReadFileFromEphemeralDevServerResponse = HandleReadFileFromEphemeralDevServerResponses[keyof HandleReadFileFromEphemeralDevServerResponses];

export type HandleWriteFileFromEphemeralDevServerData = {
    body?: never;
    path: {
        /**
         * The path to the file to read from the dev server
         */
        filepath: string;
    };
    query?: never;
    url: '/ephemeral/v1/dev-servers/files/{filepath}';
};

export type HandleWriteFileFromEphemeralDevServerErrors = {
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HandleWriteFileFromEphemeralDevServerError = HandleWriteFileFromEphemeralDevServerErrors[keyof HandleWriteFileFromEphemeralDevServerErrors];

export type HandleWriteFileFromEphemeralDevServerResponses = {
    /**
     * Successful
     */
    200: {
        id: string;
        isNew: boolean;
    };
};

export type HandleWriteFileFromEphemeralDevServerResponse = HandleWriteFileFromEphemeralDevServerResponses[keyof HandleWriteFileFromEphemeralDevServerResponses];

export type HandleGitCommitPushData = {
    body: GitCommitPushRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/git/commit-push';
};

export type HandleGitCommitPushErrors = {
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HandleGitCommitPushError = HandleGitCommitPushErrors[keyof HandleGitCommitPushErrors];

export type HandleGitCommitPushResponses = {
    /**
     * Successful
     */
    200: {
        id: string;
        isNew: boolean;
    };
};

export type HandleGitCommitPushResponse = HandleGitCommitPushResponses[keyof HandleGitCommitPushResponses];

export type HandleDevServerLogsData = {
    body: DevServerLogsRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/logs';
};

export type HandleDevServerLogsErrors = {
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HandleDevServerLogsError = HandleDevServerLogsErrors[keyof HandleDevServerLogsErrors];

export type HandleDevServerLogsResponses = {
    /**
     * Successful
     */
    200: {
        logs: Array<string>;
    };
};

export type HandleDevServerLogsResponse = HandleDevServerLogsResponses[keyof HandleDevServerLogsResponses];

export type HandleDevServerRestartData = {
    body: DevServerRestartRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/restart';
};

export type HandleDevServerRestartErrors = {
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HandleDevServerRestartError = HandleDevServerRestartErrors[keyof HandleDevServerRestartErrors];

export type HandleDevServerRestartResponses = {
    /**
     * Successful
     */
    200: {
        restarted: boolean;
    };
};

export type HandleDevServerRestartResponse = HandleDevServerRestartResponses[keyof HandleDevServerRestartResponses];

export type HandleShutdownDevServerData = {
    body: ShutdownDevServerRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/shutdown';
};

export type HandleShutdownDevServerErrors = {
    /**
     * Bad Request
     */
    400: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Not Found
     */
    404: {
        message: string;
    };
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HandleShutdownDevServerError = HandleShutdownDevServerErrors[keyof HandleShutdownDevServerErrors];

export type HandleShutdownDevServerResponses = {
    /**
     * Success
     */
    200: {
        success: boolean;
        message: string;
    };
};

export type HandleShutdownDevServerResponse = HandleShutdownDevServerResponses[keyof HandleShutdownDevServerResponses];

export type HandleDevServerStatusData = {
    body: DevServerStatusRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/status';
};

export type HandleDevServerStatusErrors = {
    /**
     * Internal Server Error
     */
    500: InternalServerError;
};

export type HandleDevServerStatusError = HandleDevServerStatusErrors[keyof HandleDevServerStatusErrors];

export type HandleDevServerStatusResponses = {
    /**
     * Successful
     */
    200: {
        installing: boolean;
        devRunning: boolean;
    };
};

export type HandleDevServerStatusResponse = HandleDevServerStatusResponses[keyof HandleDevServerStatusResponses];

export type HandleWatchDevServerFilesData = {
    body: DevServerWatchFilesRequest;
    path?: never;
    query?: never;
    url: '/ephemeral/v1/dev-servers/watch-files';
};

export type HandleWatchDevServerFilesResponses = {
    /**
     * Stream of file events
     */
    200: string;
};

export type HandleWatchDevServerFilesResponse = HandleWatchDevServerFilesResponses[keyof HandleWatchDevServerFilesResponses];

export type HandleListExecuteRunsData = {
    body?: never;
    path?: never;
    query?: {
        limit?: number | null;
        offset?: number | null;
    };
    url: '/execute/v1/deployments';
};

export type HandleListExecuteRunsErrors = {
    500: {
        message: string;
    };
};

export type HandleListExecuteRunsError = HandleListExecuteRunsErrors[keyof HandleListExecuteRunsErrors];

export type HandleListExecuteRunsResponses = {
    200: {
        entries: Array<ExecuteLogEntry>;
        total: number;
        offset: number;
    };
};

export type HandleListExecuteRunsResponse = HandleListExecuteRunsResponses[keyof HandleListExecuteRunsResponses];

export type HandleGetExecuteRunData = {
    body?: never;
    path: {
        deployment: string;
    };
    query?: never;
    url: '/execute/v1/deployments/{deployment}';
};

export type HandleGetExecuteRunErrors = {
    /**
     * Unauthorized access
     */
    401: {
        message: string;
    };
    /**
     * Not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleGetExecuteRunError = HandleGetExecuteRunErrors[keyof HandleGetExecuteRunErrors];

export type HandleGetExecuteRunResponses = {
    /**
     * Success
     */
    200: {
        metadata: ExecuteLogEntry;
        code?: null | ExecuteRunInfo;
    };
};

export type HandleGetExecuteRunResponse = HandleGetExecuteRunResponses[keyof HandleGetExecuteRunResponses];

export type HandleExecuteScriptData = {
    body: FreestyleExecuteScriptParams;
    path?: never;
    query?: never;
    url: '/execute/v1/script';
};

export type HandleExecuteScriptErrors = {
    /**
     * Error
     */
    400: {
        error: string;
        logs?: Array<FreestyleJavaScriptLog> | null;
    };
    /**
     * Internal server error
     */
    500: {
        error: string;
        logs?: Array<FreestyleJavaScriptLog> | null;
    };
};

export type HandleExecuteScriptError = HandleExecuteScriptErrors[keyof HandleExecuteScriptErrors];

export type HandleExecuteScriptResponses = {
    /**
     * Success
     */
    200: {
        /**
         * The return value of the default export of the script
         */
        result: unknown;
        logs: Array<FreestyleJavaScriptLog>;
    };
};

export type HandleExecuteScriptResponse = HandleExecuteScriptResponses[keyof HandleExecuteScriptResponses];

export type HandleListIdentitiesData = {
    body?: never;
    path?: never;
    query?: {
        limit?: number | null;
        offset?: number | null;
        includeManaged?: boolean | null;
    };
    url: '/git/v1/identity';
};

export type HandleListIdentitiesErrors = {
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleListIdentitiesError = HandleListIdentitiesErrors[keyof HandleListIdentitiesErrors];

export type HandleListIdentitiesResponses = {
    200: {
        identities: Array<GitIdentity>;
        offset: number;
        total: number;
    };
};

export type HandleListIdentitiesResponse = HandleListIdentitiesResponses[keyof HandleListIdentitiesResponses];

export type HandleCreateIdentityData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/git/v1/identity';
};

export type HandleCreateIdentityErrors = {
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleCreateIdentityError = HandleCreateIdentityErrors[keyof HandleCreateIdentityErrors];

export type HandleCreateIdentityResponses = {
    /**
     * Identity created successfully
     */
    200: GitIdentity;
};

export type HandleCreateIdentityResponse = HandleCreateIdentityResponses[keyof HandleCreateIdentityResponses];

export type HandleDeleteIdentityData = {
    body?: never;
    path: {
        identity: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}';
};

export type HandleDeleteIdentityErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Identity not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleDeleteIdentityError = HandleDeleteIdentityErrors[keyof HandleDeleteIdentityErrors];

export type HandleDeleteIdentityResponses = {
    /**
     * Identity deleted
     */
    200: {
        [key: string]: unknown;
    };
};

export type HandleDeleteIdentityResponse = HandleDeleteIdentityResponses[keyof HandleDeleteIdentityResponses];

export type HandleListPermissionsData = {
    body?: never;
    path: {
        identity: string;
    };
    query?: {
        /**
         * Maximum number of repositories to return
         */
        limit?: number;
        /**
         * Offset for the list of repositories
         */
        offset?: number;
    };
    url: '/git/v1/identity/{identity}/permissions';
};

export type HandleListPermissionsErrors = {
    /**
     * Unauthorized
     */
    401: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleListPermissionsError = HandleListPermissionsErrors[keyof HandleListPermissionsErrors];

export type HandleListPermissionsResponses = {
    /**
     * Permission list
     */
    200: ListPermissionResponseSuccess;
};

export type HandleListPermissionsResponse = HandleListPermissionsResponses[keyof HandleListPermissionsResponses];

export type HandleRevokePermissionData = {
    body?: never;
    path: {
        identity: string;
        repo: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/permissions/{repo}';
};

export type HandleRevokePermissionErrors = {
    /**
     * Unauthorized
     */
    401: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleRevokePermissionError = HandleRevokePermissionErrors[keyof HandleRevokePermissionErrors];

export type HandleRevokePermissionResponses = {
    /**
     * Permission revoked successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type HandleRevokePermissionResponse = HandleRevokePermissionResponses[keyof HandleRevokePermissionResponses];

export type HandleDescribePermissionData = {
    body?: never;
    path: {
        identity: string;
        repo: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/permissions/{repo}';
};

export type HandleDescribePermissionErrors = {
    /**
     * Unauthorized
     */
    401: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleDescribePermissionError = HandleDescribePermissionErrors[keyof HandleDescribePermissionErrors];

export type HandleDescribePermissionResponses = {
    /**
     * Permission info
     */
    200: DescribePermissionResponseSuccess;
};

export type HandleDescribePermissionResponse = HandleDescribePermissionResponses[keyof HandleDescribePermissionResponses];

export type HandleUpdatePermissionData = {
    body: UpdatePermissionRequest;
    path: {
        identity: string;
        repo: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/permissions/{repo}';
};

export type HandleUpdatePermissionErrors = {
    /**
     * Unauthorized
     */
    401: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleUpdatePermissionError = HandleUpdatePermissionErrors[keyof HandleUpdatePermissionErrors];

export type HandleUpdatePermissionResponses = {
    /**
     * Permission updated successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type HandleUpdatePermissionResponse = HandleUpdatePermissionResponses[keyof HandleUpdatePermissionResponses];

export type HandleGrantPermissionData = {
    body: GrantPermissionRequest;
    path: {
        identity: string;
        repo: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/permissions/{repo}';
};

export type HandleGrantPermissionErrors = {
    /**
     * Unauthorized
     */
    401: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Repository not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleGrantPermissionError = HandleGrantPermissionErrors[keyof HandleGrantPermissionErrors];

export type HandleGrantPermissionResponses = {
    /**
     * Permission granted successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type HandleGrantPermissionResponse = HandleGrantPermissionResponses[keyof HandleGrantPermissionResponses];

export type HandleRevokeGitTokenData = {
    body: RevokeGitTokenRequest;
    path: {
        identity: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/tokens';
};

export type HandleRevokeGitTokenErrors = {
    /**
     * Unauthorized
     */
    401: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleRevokeGitTokenError = HandleRevokeGitTokenErrors[keyof HandleRevokeGitTokenErrors];

export type HandleRevokeGitTokenResponses = {
    /**
     * Token revoked
     */
    200: {
        [key: string]: unknown;
    };
};

export type HandleRevokeGitTokenResponse = HandleRevokeGitTokenResponses[keyof HandleRevokeGitTokenResponses];

export type HandleListGitTokensData = {
    body?: never;
    path: {
        identity: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/tokens';
};

export type HandleListGitTokensErrors = {
    /**
     * Unauthorized
     */
    401: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleListGitTokensError = HandleListGitTokensErrors[keyof HandleListGitTokensErrors];

export type HandleListGitTokensResponses = {
    /**
     * Token list
     */
    200: ListGitTokensResponseSuccess;
};

export type HandleListGitTokensResponse = HandleListGitTokensResponses[keyof HandleListGitTokensResponses];

export type HandleCreateGitTokenData = {
    body?: never;
    path: {
        identity: string;
    };
    query?: never;
    url: '/git/v1/identity/{identity}/tokens';
};

export type HandleCreateGitTokenErrors = {
    /**
     * Unauthorized
     */
    401: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleCreateGitTokenError = HandleCreateGitTokenErrors[keyof HandleCreateGitTokenErrors];

export type HandleCreateGitTokenResponses = {
    /**
     * Token created successfully
     */
    200: CreatedToken;
};

export type HandleCreateGitTokenResponse = HandleCreateGitTokenResponses[keyof HandleCreateGitTokenResponses];

export type HandleListRepositoriesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Maximum number of repositories to return
         */
        limit?: number;
        /**
         * Offset for the list of repositories
         */
        offset?: number;
    };
    url: '/git/v1/repo';
};

export type HandleListRepositoriesErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleListRepositoriesError = HandleListRepositoriesErrors[keyof HandleListRepositoriesErrors];

export type HandleListRepositoriesResponses = {
    /**
     * List of repositories
     */
    200: {
        repositories: Array<RepositoryMetadata>;
        total: number;
        offset: number;
    };
};

export type HandleListRepositoriesResponse = HandleListRepositoriesResponses[keyof HandleListRepositoriesResponses];

export type HandleCreateRepoData = {
    body: {
        /**
         * This name is not visible to users, and is only accessible to you via API and in the
         * dashboard. Mostly useful for observability.
         */
        name?: string | null;
        public?: boolean;
        /**
         * The default branch name for the repository. Defaults to "main" if not specified.
         */
        defaultBranch?: string | null;
        /**
         * Fork from another Git repository. Cannot be used with `import`.
         */
        source?: CreateRepoSource;
        /**
         * Import static content with an initial commit. Cannot be used with `source`.
         */
        import?: CreateRepoImport;
    };
    path?: never;
    query?: never;
    url: '/git/v1/repo';
};

export type HandleCreateRepoErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleCreateRepoError = HandleCreateRepoErrors[keyof HandleCreateRepoErrors];

export type HandleCreateRepoResponses = {
    /**
     * Repository created successfully
     */
    200: CreateRepositoryResponseSuccess;
};

export type HandleCreateRepoResponse = HandleCreateRepoResponses[keyof HandleCreateRepoResponses];

export type HandleGetDefaultBranchData = {
    body?: never;
    path: {
        /**
         * The repository ID
         */
        repo_id: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo_id}/default-branch';
};

export type HandleGetDefaultBranchResponses = {
    /**
     * Success
     */
    200: GetDefaultBranchResponse;
};

export type HandleGetDefaultBranchResponse = HandleGetDefaultBranchResponses[keyof HandleGetDefaultBranchResponses];

export type HandleSetDefaultBranchData = {
    body: SetDefaultBranchRequest;
    path: {
        /**
         * The repository ID
         */
        repo_id: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo_id}/default-branch';
};

export type HandleSetDefaultBranchResponses = {
    /**
     * Success
     */
    200: SetDefaultBranchResponse;
};

export type HandleSetDefaultBranchResponse = HandleSetDefaultBranchResponses[keyof HandleSetDefaultBranchResponses];

export type RemoveGithubSyncData = {
    body?: never;
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo_id}/github-sync';
};

export type RemoveGithubSyncErrors = {
    /**
     * Repository or sync configuration not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type RemoveGithubSyncResponses = {
    /**
     * GitHub sync configuration removed successfully
     */
    200: unknown;
};

export type GetGithubSyncData = {
    body?: never;
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo_id}/github-sync';
};

export type GetGithubSyncErrors = {
    /**
     * Repository or sync configuration not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetGithubSyncResponses = {
    /**
     * GitHub sync configuration
     */
    200: GithubSyncConfigResponse;
};

export type GetGithubSyncResponse = GetGithubSyncResponses[keyof GetGithubSyncResponses];

export type ConfigureGithubSyncData = {
    body: ConfigureGithubSyncRequest;
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo_id}/github-sync';
};

export type ConfigureGithubSyncErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Repository not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ConfigureGithubSyncResponses = {
    /**
     * GitHub sync configured successfully
     */
    200: unknown;
};

export type HandleDeleteRepoData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}';
};

export type HandleDeleteRepoErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * User does not have permission to delete this repository
     */
    403: {
        message: string;
    };
    /**
     * Repository does not exist
     */
    404: {
        [key: string]: unknown;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleDeleteRepoError = HandleDeleteRepoErrors[keyof HandleDeleteRepoErrors];

export type HandleDeleteRepoResponses = {
    /**
     * Repository deleted successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type HandleDeleteRepoResponse = HandleDeleteRepoResponses[keyof HandleDeleteRepoResponses];

export type HandleGetRepoInfoData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}';
};

export type HandleGetRepoInfoErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Forbidden access to repository
     */
    403: unknown;
    /**
     * Repository not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type HandleGetRepoInfoResponses = {
    /**
     * Repository information retrieved successfully
     */
    200: RepositoryInfo;
};

export type HandleGetRepoInfoResponse = HandleGetRepoInfoResponses[keyof HandleGetRepoInfoResponses];

export type HandleGetContentsData = {
    body?: never;
    path: {
        /**
         * The repository ID.
         */
        repo: string;
        /**
         * The path to the file or directory. Empty for root.
         */
        path: string | null;
    };
    query?: {
        /**
         * The git reference (branch name, commit SHA, etc.). Defaults to HEAD.
         */
        ref?: string;
    };
    url: '/git/v1/repo/{repo}/contents/{path}';
};

export type HandleGetContentsErrors = {
    /**
     * Bad Request
     */
    400: {
        message: string;
    };
    /**
     * Unauthorized
     */
    401: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Not Found
     */
    404: {
        message: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        message: string;
    };
};

export type HandleGetContentsError = HandleGetContentsErrors[keyof HandleGetContentsErrors];

export type HandleGetContentsResponses = {
    /**
     * Success
     */
    200: GitContents;
};

export type HandleGetContentsResponse = HandleGetContentsResponses[keyof HandleGetContentsResponses];

export type HandleGetBlobData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The object's hash
         */
        hash: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/blobs/{hash}';
};

export type HandleGetBlobErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Blob not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleGetBlobError = HandleGetBlobErrors[keyof HandleGetBlobErrors];

export type HandleGetBlobResponses = {
    /**
     * Blob retrieved successfully
     */
    200: BlobObject;
};

export type HandleGetBlobResponse = HandleGetBlobResponses[keyof HandleGetBlobResponses];

export type HandleListCommitsData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: {
        /**
         * Branch name (defaults to HEAD)
         */
        branch?: string | null;
        /**
         * Maximum number of commits to return (default: 50, max: 500)
         */
        limit?: number | null;
        /**
         * Number of commits to skip (default: 0)
         */
        offset?: number | null;
    };
    url: '/git/v1/repo/{repo}/git/commits';
};

export type HandleListCommitsErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Repository or branch not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleListCommitsError = HandleListCommitsErrors[keyof HandleListCommitsErrors];

export type HandleListCommitsResponses = {
    /**
     * Commits retrieved successfully
     */
    200: CommitList;
};

export type HandleListCommitsResponse = HandleListCommitsResponses[keyof HandleListCommitsResponses];

export type HandleGetCommitData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The object's hash
         */
        hash: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/commits/{hash}';
};

export type HandleGetCommitErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Commit not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleGetCommitError = HandleGetCommitErrors[keyof HandleGetCommitErrors];

export type HandleGetCommitResponses = {
    /**
     * Commit retrieved successfully
     */
    200: CommitObject;
};

export type HandleGetCommitResponse = HandleGetCommitResponses[keyof HandleGetCommitResponses];

export type HandleGetRefBranchData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The branch's name
         */
        branch: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/refs/heads/{branch}';
};

export type HandleGetRefBranchErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Branch not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleGetRefBranchError = HandleGetRefBranchErrors[keyof HandleGetRefBranchErrors];

export type HandleGetRefBranchResponses = {
    /**
     * Branch reference object
     */
    200: GitReference;
};

export type HandleGetRefBranchResponse = HandleGetRefBranchResponses[keyof HandleGetRefBranchResponses];

export type HandleGetRefTagData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The tag's name
         */
        tag: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/refs/tags/{tag}';
};

export type HandleGetRefTagErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Branch not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleGetRefTagError = HandleGetRefTagErrors[keyof HandleGetRefTagErrors];

export type HandleGetRefTagResponses = {
    /**
     * Branch reference object
     */
    200: GitReference;
};

export type HandleGetRefTagResponse = HandleGetRefTagResponses[keyof HandleGetRefTagResponses];

export type HandleGetTagData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The object's hash
         */
        hash: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/tags/{hash}';
};

export type HandleGetTagErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Tag not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleGetTagError = HandleGetTagErrors[keyof HandleGetTagErrors];

export type HandleGetTagResponses = {
    /**
     * Tag retrieved successfully
     */
    200: TagObject;
};

export type HandleGetTagResponse = HandleGetTagResponses[keyof HandleGetTagResponses];

export type HandleGetTreeData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The object's hash
         */
        hash: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/git/trees/{hash}';
};

export type HandleGetTreeErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Tree not found
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleGetTreeError = HandleGetTreeErrors[keyof HandleGetTreeErrors];

export type HandleGetTreeResponses = {
    /**
     * Tree retrieved successfully
     */
    200: TreeObject;
};

export type HandleGetTreeResponse = HandleGetTreeResponses[keyof HandleGetTreeResponses];

export type HandleDownloadTarballData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: {
        /**
         * The git reference (branch name, commit SHA, etc.). Defaults to HEAD.
         */
        ref?: string;
    };
    url: '/git/v1/repo/{repo}/tarball';
};

export type HandleDownloadTarballErrors = {
    /**
     * Bad Request
     */
    400: {
        message: string;
    };
    /**
     * Unauthorized
     */
    401: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Not Found
     */
    404: {
        message: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        message: string;
    };
};

export type HandleDownloadTarballError = HandleDownloadTarballErrors[keyof HandleDownloadTarballErrors];

export type HandleDownloadTarballResponses = {
    /**
     * Success (byte stream)
     */
    200: Blob | File;
};

export type HandleDownloadTarballResponse = HandleDownloadTarballResponses[keyof HandleDownloadTarballResponses];

export type HandleListGitTriggersData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/trigger';
};

export type HandleListGitTriggersErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * User does not have permission to access this repository
     */
    403: {
        message: string;
    };
    /**
     * Repository does not exist
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleListGitTriggersError = HandleListGitTriggersErrors[keyof HandleListGitTriggersErrors];

export type HandleListGitTriggersResponses = {
    /**
     * Success
     */
    200: {
        triggers: Array<GitRepositoryTrigger>;
    };
};

export type HandleListGitTriggersResponse = HandleListGitTriggersResponses[keyof HandleListGitTriggersResponses];

export type HandleCreateGitTriggerData = {
    body: {
        trigger: {
            branches?: Array<string> | null;
            globs?: Array<string> | null;
            event: 'push';
        };
        action: {
            endpoint: string;
            action: 'webhook';
        };
    };
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/trigger';
};

export type HandleCreateGitTriggerErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * User does not have permission to create a trigger on this repository
     */
    403: {
        message: string;
    };
    /**
     * Repository does not exist
     */
    404: {
        message: string;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleCreateGitTriggerError = HandleCreateGitTriggerErrors[keyof HandleCreateGitTriggerErrors];

export type HandleCreateGitTriggerResponses = {
    /**
     * Trigger created successfully
     */
    200: {
        triggerId: string;
    };
};

export type HandleCreateGitTriggerResponse = HandleCreateGitTriggerResponses[keyof HandleCreateGitTriggerResponses];

export type HandleDeleteGitTriggerData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The trigger id
         */
        trigger: string;
    };
    query?: never;
    url: '/git/v1/repo/{repo}/trigger/{trigger}';
};

export type HandleDeleteGitTriggerErrors = {
    /**
     * Invalid request
     */
    400: {
        message: string;
    };
    /**
     * User does not have permission to delete a trigger on this repository
     */
    403: {
        message: string;
    };
    /**
     * Trigger does not exist
     */
    404: {
        [key: string]: unknown;
    };
    /**
     * Internal server error
     */
    500: {
        message: string;
    };
};

export type HandleDeleteGitTriggerError = HandleDeleteGitTriggerErrors[keyof HandleDeleteGitTriggerErrors];

export type HandleDeleteGitTriggerResponses = {
    /**
     * Trigger deleted successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type HandleDeleteGitTriggerResponse = HandleDeleteGitTriggerResponses[keyof HandleDeleteGitTriggerResponses];

export type HandleDownloadZipData = {
    body?: never;
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: {
        /**
         * The git reference (branch name, commit SHA, etc.). Defaults to HEAD.
         */
        ref?: string;
    };
    url: '/git/v1/repo/{repo}/zip';
};

export type HandleDownloadZipErrors = {
    /**
     * Bad Request
     */
    400: {
        message: string;
    };
    /**
     * Unauthorized
     */
    401: {
        message: string;
    };
    /**
     * Forbidden
     */
    403: {
        message: string;
    };
    /**
     * Not Found
     */
    404: {
        message: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        message: string;
    };
};

export type HandleDownloadZipError = HandleDownloadZipErrors[keyof HandleDownloadZipErrors];

export type HandleDownloadZipResponses = {
    /**
     * Success (byte stream)
     */
    200: Blob | File;
};

export type HandleDownloadZipResponse = HandleDownloadZipResponses[keyof HandleDownloadZipResponses];

export type HandleGetLogsData = {
    body?: never;
    path?: never;
    query?: {
        deploymentId?: string | null;
        domain?: string | null;
    };
    url: '/observability/v1/logs';
};

export type HandleGetLogsResponses = {
    200: FreestyleGetLogsResponse;
};

export type HandleGetLogsResponse = HandleGetLogsResponses[keyof HandleGetLogsResponses];

export type ListVmsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/vms';
};

export type CreateVmData = {
    body: CreateVmRequest;
    path?: never;
    query?: never;
    url: '/v1/vms';
};

export type ResizeVmData = {
    body: ResizeVmRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/vms/{id}/resize';
};

export type DeleteVmData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to delete
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}';
};

export type GetVmData = {
    body?: never;
    path: {
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}';
};

export type WaitVmData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to wait for
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/await';
};

export type ExecAwaitData = {
    body: ExecAwaitRequest;
    path: {
        /**
         * The ID of the VM to execute the command in
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/exec-await';
};

export type GetFileData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to get the file from
         */
        vm_id: string;
        /**
         * The path of the file to get
         */
        filepath: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/files/{filepath}';
};

export type PutFileData = {
    body: WriteFileRequest;
    path: {
        /**
         * The ID of the VM to put the file to
         */
        vm_id: string;
        /**
         * The path of the file to put
         */
        filepath: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/files/{filepath}';
};

export type ForkVmData = {
    body: ForkVmRequest;
    path: {
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/fork';
};

export type OptimizeVmData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to optimize
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/optimize';
};

export type StartVmData = {
    body: StartVmRequest;
    path: {
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/start';
};

export type StopVmData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to stop
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/stop';
};

export type SuspendVmData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to suspend
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/suspend';
};

export type ListTerminalsData = {
    body?: never;
    path: {
        /**
         * The ID of the VM
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/terminals';
};

export type GetTerminalLogsData = {
    body?: never;
    path: {
        /**
         * The ID of the VM
         */
        vm_id: string;
        /**
         * The ID of the terminal session
         */
        terminal_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/terminals/{terminal_id}/logs';
};

export type GetTerminalXtermData = {
    body?: never;
    path: {
        /**
         * The ID of the VM
         */
        vm_id: string;
        /**
         * The ID of the terminal session
         */
        terminal_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/terminals/{terminal_id}/xterm-256color';
};

export type WatchFilesData = {
    body?: never;
    path: {
        /**
         * The ID of the VM to watch files for
         */
        vm_id: string;
    };
    query?: never;
    url: '/v1/vms/{vm_id}/watch-files';
};

export type HandleDeployWebData = {
    body: FreestyleDeployWebPayload;
    path?: never;
    query?: never;
    url: '/web/v1/deploy';
};

export type HandleDeployWebErrors = {
    /**
     * failed to deploy
     */
    400: FreestyleDeployWebErrorResponse;
};

export type HandleDeployWebError = HandleDeployWebErrors[keyof HandleDeployWebErrors];

export type HandleDeployWebResponses = {
    /**
     * successfully deployed
     */
    200: FreestyleDeployWebSuccessResponseV2;
};

export type HandleDeployWebResponse = HandleDeployWebResponses[keyof HandleDeployWebResponses];

export type HandleDeployWebV2Data = {
    body: FreestyleDeployWebPayloadV2;
    path?: never;
    query?: never;
    url: '/web/v1/deployment';
};

export type HandleDeployWebV2Errors = {
    /**
     * failed to deploy
     */
    400: FreestyleDeployWebErrorResponse;
};

export type HandleDeployWebV2Error = HandleDeployWebV2Errors[keyof HandleDeployWebV2Errors];

export type HandleDeployWebV2Responses = {
    /**
     * successfully deployed
     */
    200: FreestyleDeployWebSuccessResponseV2;
};

export type HandleDeployWebV2Response = HandleDeployWebV2Responses[keyof HandleDeployWebV2Responses];

export type HandleListWebDeploysData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Maximum number of repositories to return
         */
        limit: number;
        /**
         * Offset for the list of repositories
         */
        offset: number;
    };
    url: '/web/v1/deployments';
};

export type HandleListWebDeploysErrors = {
    500: {
        message: string;
    };
};

export type HandleListWebDeploysError = HandleListWebDeploysErrors[keyof HandleListWebDeploysErrors];

export type HandleListWebDeploysResponses = {
    200: {
        entries: Array<DeploymentLogEntry>;
        total: number;
        offset: number;
    };
};

export type HandleListWebDeploysResponse = HandleListWebDeploysResponses[keyof HandleListWebDeploysResponses];

export type HandleGetWebDeployDetailsData = {
    body?: never;
    path: {
        deployment_id: string;
    };
    query?: never;
    url: '/web/v1/deployments/deployment/{deployment_id}';
};

export type ClientOptions = {
    baseUrl: 'https://api.freestyle.sh' | (string & {});
};